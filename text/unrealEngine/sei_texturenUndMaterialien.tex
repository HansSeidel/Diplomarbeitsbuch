\section{Texturierung}
\label{sec:tex}
Texturen geben dem erstellten Objekt komplexe Farben. Um einen Bezug zu realen Objekten zu schaffen, müssen Texturen
auf 3Dimensionalen Objekten angewandt werden. Zum Beispiel kann man einen Baum bis
zum kleinsten Detail modellieren und mittels verschiedener Materialien einfärben. Die Natürlichkeit
eines echten Baums wird dieses Modell nicht erreichen.

Es gibt Spiele, welche die Texturanzahl sehr gering halten. In diesem Fall wird eher ein Comic
oder Low-Polygon Stil verfolgt.

Allerdings werden Texturen nicht nur für die Farbe verwendet, sondern auch für Materialeinstellungen.
Einige dieser Texturarten wurden für dieses Projekt verwendet und
sind in den nächsten Kapiteln zu finden.

%-----------------Mapping Methoden-----------------Mapping Methoden------------------Mapping Methoden-------------------
\subsection{Mapping Methoden}
\label{sec:tex_mapping}

Bei der Texturierung eines Objektes unterscheidet man zwischen verschiedenen Mapping Methoden. Mapping bezeichnet man
den Prozess, eine Textur aus dem 2-Dimensionalen Bereich auf ein Objekt im 3-Dimensionalen Bereich zu übertragen. Die
meist verwendeten Mapping Methoden sind das generierte Mapping und das UV-Mapping\citep{blender:tex_mapping_modes}:


Generiertes Mapping:

Generiertes Mapping bedeutet, dass man die Grundform eines komplexen Objektes angibt (Z.b. Cube / Zylinder ). Die
eingefügte Textur wird dann entsprechend der Grundform über das Objekt "gemappt". Die Angabe der Grundform beschreibt
wie die 2-Dimensionale Textur in der 3Dimensionalen Welt auf dem Objekt angezeigt werden soll.
Bei der generierten Texturierung kann es allerdings zu Fehlern kommen. Es kommt vor, dass die Textur von einer
bestimmten Seiten korrekt und auf anderen Seite langezogen angezeigt wird. Dass liegt daran, dass die Pixel einer
Textur (2Dimensionaler Bereich) auf eine 3Dimensionale Fläche projiziert werden, in welcher sie keine Informationen
über die dritte Achse besitzen (Siehe Abbildung \ref{picture:tex_streching}).

\begin{figure}[h]
    \centering
    \includegraphics[width=.9\textwidth]{SEI_Texturierung_Methoden-Pixelstretching.png}
    \caption{Die Pixel der Textur werden der Y-Achse entlang auf der oberen Fläche des Würfels gestreckt}
    \label{picture:tex_streching}
\end{figure}

Der einfachste Weg, diesen Fehler zu umgehen ist es, ein UV-Layout zu generieren. Allerdings ist es auch mit dem
Node-System der Unreal-Engine\citep{ue:node_introduction} möglich (Siehe Abbildung \ref{picture:tex_streching_solve}).


\begin{figure}[h]
    \centering
    \includegraphics[width=.9\textwidth]{SEI_Texturierung_Methoden-PixelstretchingMaterialKorrektur.png}
    \caption{Eine komlexere Lösung der Fehler-Behebung. Die einfache Methode ist UV-Mapping}
    \label{picture:tex_streching_solve}
\end{figure}


UV-Mapping:

UV-Mapping ist eine sehr sichere Art der Texturierung. Beim UV-Mapping wird eine Textur dem UV-Layout des Objektes
angepasst. Dies kann automatisch passieren oder bewusst beeinflusst. Bei komplexeren Objekten wird das UV-Layout
exportiert und eine Textur mittels eines Fotoprogramms oder dem Blender Texture-Painting Tool erstellt
(Mehr Informationen zu UV-Mapping und dem Blender Texture-Painting Tool sind in den Kapiteln \ref{sec:unwrapping} und
dem Kapitel \ref{sec:texture_painting})


Weiter aufbauende Mapping-Methoden die mittels dem Node-System der Unreal Engine möglich sind, sind die WorldAlign
Mapping Methode, View-Ported Mapping Methode und die Objektrelative Mapping Methode. Diese Arten wurden im Laufe
des Projektes nicht verwendet und sind daher nicht Teil dieses Buches.

Die nächsten Kapitel (Diffuse Texturen, Bump- Normal-Texturen, Ambient Occlusion Texturen, Roughness Texturen)
beschreiben verschiedene Textur-Arten, die am häufigsten bei der Spielentwicklung eingesetzt werden. Für die
Entwicklung und Bearbeitung dieser Texturen wurde das Programm "Materialize" - von Bounding Box
Software\citep{bbs:materialize} - verwendet. Dieses Programm ist eine OpenSource Entwicklung, mit freier Lizenz.


%-----------------Diffuse Texturen-----------------Diffuse Texturen------------------Diffuse Texturen-------------------
\subsection{Diffuse Texturen}
\label{sec:tex_diffuse}

Diffuse Texturen\citep{blender:tex_introduction} bestimmen das grundlegende Aussehen des Objektes. Sie beinhalten die Farbinformationen des
Objektes.
In vielen Fällen werden diffuse Texturen seamless gestaltet. Eine Textur ist seamless, wenn eine Kopie der Textur an
jede Seite gelegt werden kann und trotzdem einen perfekten Übergang bildet.

%----------Bump und Normal Texturen------Bump und Normal Texturen------------Bump und Normal Texturen-------------------
\subsection{Bump und Normal Texturen}
\label{sec:tex_normal}

Eine Bump- oder Normal-Textur (meisten Bump- / Normal-Map genannt), simuliert die Höhen und Tiefen eines Objektes.
Das funktioniert, indem das Licht auf dem Objekt verschieden berechnet wird.\citep{unity:normal_vs_bump}


Bump-Maps:

Bump-Maps sind die ältere Methode der Höhenberechnung. Bump-Maps sind schwarz-weiß Texturen. Die schwarzen Pixel
zeigen Vertiefungen an, die weißen Pixel Erhöhungen. Je nachdem, wie die Normals der betreffenden Fläche ausgerichtet
sind, wird diese Fläche an gewissen Stellen schwäche beleuchtet / reflektieren als an anderen Stellen. Die Normals
einer Fläche sind die belichteten Seiten. Die Normal-Direction gibt an, aus welcher Richtung die Textur angezeigt
wird und welche Neigung die Fläche hat (Siehe Abbildung \ref{picture:normals}).

\begin{figure}[h]
    \centering
    \includegraphics[width=.9\textwidth]{SEI_Texturierung_Bump-NormalTexturen-Normals.png}
    \caption{In diesem Bild sieht man die Normal-Direction der verschiedenen Flächen}
    \label{picture:normals}
\end{figure}


Normal-Maps:

Normal-Texturen speichern etwas mehr Informationen. Während eine Bump-Textur nur die \textit{gefälschte} Tiefe
speichert, beinhalten Normal-Texturen auch die Lichtberechnung aus verschiedenen Perspektiven (rechte Seite,
linke obere Seite, frontale Seite). Diese Informationen werden in einer Normal-Map in den R-G-B Kanälen gespeichert.

In unserer Diplomarbeit wurden ausschließlich Normal-Maps verwendet, da sie mittels dem Programm
Materialize\citep{bbs:materialize} relative einfach zu erstellen sind. Bump und Normal-Texturen sind in den meisten
Fällen gleichwertig außer bei Objekten die Rundungen haben. In diesem Fall sind Normal-Texturen die bessere Wahl
um Details von seitlicher Perspektive zu generieren.

%----------------Roughness Texturen---------------Roughness Texturen---------------Roughness Texturen-------------------
\subsection{Roughness Texturen}
\label{sec:tex_roughness}

Roughness Texturen werden für die Spiegelung verwendet. Die Roughness bestimmt, mit welcher Streuung das Objekt Licht
reflektiert wird. Ein Roughness Wert von null (schwarz) entspricht kompletter Spiegelung. Ein Roughness Wert von eins
(weiß) entspricht gar keiner Spiegelung (Siehe Abbildung \ref{picture:roughness_illustration}).

\begin{figure}[h]
    \centering
    \includegraphics[width=.9\textwidth]{SEI_Texturierung_Roughness-Roughness.png}
    \caption{Darstellung der Lichtberechnung eines Roughness-Wertes}
    \label{picture:roughness_illustration}
\end{figure}


Das Programm Materialize verwendet Smoothness-Maps. Wenn eine Smoothness-Map für den Roughness-Wert verwendet wird,
muss er invertiert werden. In der Unreal-Engine funktioniert das mittels der 1-x Funktion (Siehe
Kapitel \ref{sec:algorithms} oder Abbildung \ref{picture:tex_mat_roughness}).

Im Normalfall befindet sich der Roughness-Wert zwischen 0,3 und 0,9. Allerdings wird für Materialien, die Wasser oder
Pfützen darstellen sollen gerne ein Roughnesswert von 0 verwendet.

%----------------Texturen in der Engine---------------Texturen in der Engine---------------Texturen in der Engine-------
\subsection{Texturen in der Engine}
\label{sec:tex_inside_engine}

Für dieses Kapitel werden einige Informationen über Materials vorab beschrieben.


Wenn in der Unreal-Engine ein neues Material erstellt wird, wird der Node-Editor\citep{ue:node_introduction} mit einer
Material Output Node geöffnet. Die Node hat verschiedene Inputs, die die physikalischen Eigenschaften des Materials
bestimmen. Die meisten Inputs akzeptieren eine konstante Value oder eine Textur. Bei einer Material Node sind nicht
alle Inputs verfügbar. Welche Inputs verfügbar sind, ist von der Material-Art abhängig (Siehe
Abbildung \ref{picture:mat_ue4_node}).

\begin{figure}[h]
    \centering
    \includegraphics[width=.9\textwidth]{SEI_Texturierung_Texturen in der Engine-MaterialOutput.png}
    \caption{Eine Material Output Node und die aktiven Inputs}
    \label{picture:mat_ue4_node}
\end{figure}


Um das System der Inputs genauer zu beschreiben verwendet wir den roughness Input. Nehmen wir als Beispiel ein Material
für eine grüne Türe und ein Material für eine Terrasse (Siehe Abbildung \ref{picture:tex_mat_roughness}).
Das erste Bild zeigt die grüne Türe. Die gesamte Türe ist ohne große Unterschiede. Die Türklinke und das Schloss haben
eigene Materialien. Daher hat die Türe einen konstanten Roughness-Wert von 0,8 (Die linke Hälfte von dem Bild zeigt
den Wert als Farbe an).

Bei der Terrasse sollen die Ziegel eine etwas geringere Roughness besitzen als die Zwischenräume. Daher wurde eine
Smoothness-Textur erstellt. Wie man sehen kann, sind die Zwischenräume der Textur dünkler, was bedeutet, dass die
Zwischenräume eine geringer Roughness hätten als die Ziegel. Damit der erwünschte Effekt erzielt wird, wurde die
1-X Node verwendet um die Textur zu invertieren.

\begin{figure}[h]
    \centering
    \includegraphics[width=.9\textwidth]{SEI_Texturierung_Texturen in der Engine-InputMoeglichkeit.png}
    \caption{Der Roughness input wurde einmal mit einem konstanten Wert verwendet und einmal mit einer Textur}
    \label{picture:tex_mat_roughness}
\end{figure}


Property-Maps / Texture Masks\citep{ue:tex_property_map}:

Die letzte Art von Texturen, die in diesem Buch näher gebracht wird, ist eine Property-Map. Property-Maps werden
verwendet, um die Performance des Spiels zu optimieren. Bei Texturen, wie zum Beispiel eine Roughness-Textur oder eine
Bump-Textur, werden nur die schwarz-weiß Informationen benötigt. Jede Textur wird allerdings einzeln von der Engine
geladen, wenn das Spiel / Level gestartet wird. Um diesen Vorgang zu optimieren, kombiniert man 3 schwarz-weiß Texturen
in einer Property-Map. Das bedeutet, dass man den Rot-Wert, den Grün-Wert und den Blau-Wert verwendet, um die
Informationen zu speichern. Da man in der Unreal-Engine die Kanäle einzeln verwenden kann und diese nur einen Wert
zwischen 0 und 1 ausgeben, funktioniert das einwandfrei. Damit hat man drei Texturen in einer
Property-Map vereint und es muss nur eine Textur geladen werden. (Siehe Abildung \ref{picture:property_map})

\begin{figure}[h]
    \centering
    \includegraphics[width=.9\textwidth]{SEI_Texturierung_Texturen in der Engine-Property-Map.png}
    \caption{Eine Property-Map und die einzelnen Informationen innerhalb der RGB-Kanäle}
    \label{picture:property_map}
\end{figure}


\section{Materialien}
\label{sec:materials}

\subsection{Material Inputs}
\label{sec:mat_inputs}

\subsection{Material-Ebenen, -Funktionen, -Instanzen}
\label{sec:mat_lay_func_ins}

\subsection{Wichtige Algorithmen/Funktionen}
\label{sec:algorithms}

